# 网络爬虫相关技术

​		网络爬虫是一个客户端技术,不能离开服务端独立工作，而服务器端由众多的分布在互联网的web服务器组成，

在这样的环境下，爬虫要从不同的配置，不同web管件的服务器上采集页面信息，就需要按照一定的协议规范

来完成交互过程。他需要遵循如下的规则。



#### 1.TCP协议

>  		TCP协议是网络爬虫的底层协议，当爬虫与web建立连接、传输数据时都是以该协议为基础的。计算机与网络设备之间如果要相互通信,双方就必须基于相同的方法.比如如何探测到通信目标.由哪一边先发起通信,使用哪种语言进行通信,怎样结束通信等规则都需要事先确定.不同的硬件,操作系统之间的通信,所有这一切都需要一种规则.而我们就将这种规则称为协议 (protocol).

![](D:\MARKDOEN_image\aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZseTFnOGQydGpzMm93ajMwbDUwZDNkamkuanBn.jpg)

> ***面向报文***
> 		面向报文的传输方式是应用层交给UDP多长的报文，UDP发送多长的报文，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。
>
> ***面向字节流***
> 		虽然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应该程序传送的数据块太长，TCP就可以把它划分短一些再传送。





> ***<u>TCP的三次握手与四次挥手</u>***
> 具体过程如下：
>
> 第一次握手：建立连接。客户端发送连接请求报文段，并将syn(标记位)设置为1，Squence Number(数据包序号)(seq)为x,接下来等待服务端确认，客户端进入SYN_SENT状态(请求连接)；
>
> 第二次握手：服务端收到客户端的 SYN 报文段，对 SYN 报文段进行确认，设置 ack(确认号)为 x+1(即seq+1 ; 同时自己还要发送 SYN 请求信息，将 SYN 设置为1, seq为 y。服务端将上述所有信息放到 SYN+ACK 报文段中，一并发送给客户端，此时服务器进入 SYN_RECV状态。
>
> SYN_RECV是指,服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态。再进一步接收到客户端的ACK就进入ESTABLISHED状态。
>
> 第三次握手：客户端收到服务端的 SYN+ACK(确认符) 报文段；然后将 ACK 设置为 y+1,向服务端发送ACK报文段，这个报文段发送完毕后，客户端和服务端都进入ESTABLISHED(连接成功)状态，完成TCP 的三次握手。

![](D:\MARKDOEN_image\aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZseTFnOGQycDNvZHA5ajMwaTQwOTQ3NHkuanBn.jpg)

当客户端和服务端通过三次握手建立了 TCP 连接以后,当数据传送完毕,断开连接就需要进行TCP的四次挥手。其四次挥手如下所示：

> 第一次挥手
>
> 客户端设置seq和 ACK ,向服务器发送一个 FIN(终结)报文段。此时，客户端进入 FIN_WAIT_1 状态，表示客户端没有数据要发送给服务端了。
>
> 第二次挥手
>
> 服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。
>
> 第三次挥手
>
> 服务端向客户端发送FIN 报文段，请求关闭连接，同时服务端进入 LAST_ACK 状态。
>
> 第四次挥手
>
> 客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段,然后客户端进入 TIME_WAIT 状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，客户端等待 2MSL（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。



![](D:\MARKDOEN_image\aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZseTFnOGQycDJzN2tnajMwOHIwOXRkZ2MuanBn.jpg)

**如果有大量的连接，每次在连接，关闭都要经历三次握手，四次挥手，这显然会造成性能低下。因此。Http 有一种叫做 长连接（keepalive connections） 的机制。它可以在传输数据后仍保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而无需再次握手。**

![](D:\MARKDOEN_image\aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZseTFnOGQycDMzdTdiajMwbDgwMnFxMnkuanBn.jpg)

一些问题汇总：
1. 为什么要三次握手？

  为了防止已失效的连接请求报文突然又传送到了服务端，因为产生错误。

具体解释： “已失效的连接请求报文段”产生情况：

> client 发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间滞留，因此导致延误到连接释放以后的某个时间才到达 service。如果没有三次握手，那么此时server收到此失效的连接请求报文段，就误认为是 client再次发出的一个新的连接请求，于是向 client 发出确认报文段，同意建立连接，而此时 client 并没有发出建立连接的情况，因此并不会理会服务端的响应，而service将会一直等待client发送数据，因此就会导致这条连接线路白白浪费。
>
> 如果此时变成两次挥手行不行？
>
> 这个时候需要明白全双工与半双工，再进行回答。比如：
>
> 第一次握手： A给B打电话说，你可以听到我说话吗？
> 第二次握手： B收到了A的信息，然后对A说： 我可以听得到你说话啊，你能听得到我说话吗？
> 第三次握手： A收到了B的信息，然后说可以的，我要给你发信息啦！
> 在三次握手之后，A和B都能确定这么一件事： 我说的话，你能听到； 你说的话，我也能听到。 这样，就可以开始正常通信了，如果是两次，那将无法确定。

2. 为什么要四次挥手？

  > TCP 协议是一种面向连接，可靠，基于字节流的传输层通信协议。TCP 是全双工模式(同一时刻可以同时发送和接收)，这就意味着，当主机1发出 FIN 报文段时，只是表示主机1已结没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回 ACK报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会中断这次TCP连接。

3.为什么要等待 2MSL

> MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间

> 原因如下：
>
> 保证TCP协议的全双工连接能够可靠关闭
> 保证这次连接的重复数据从网络中消息
>
> 第一点： 如果主机1直接 关闭，由于IP协议的不可靠性或者其他网络原因，导致主机2没有收到主机1最后回复的 ACK。那么主机2就会在超时之后继续发送 FIN，此时由于主机1已经关闭，就找不到与重发的 FIN 对应的连接。所以，主机1 不是直接进入 关闭，而是TIME_WAIT 状态。当再次收到 FIN 的时候，能够保证对方收到 ACK ，最后正确关闭连接。
>
> 第二点：如果主机1直接 关闭，然后又再向主机 2 发起一个新连接，我们不能保证这个新连接与刚才关闭的连接端口是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但还是有特殊情况出现；假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中( Lost Duplicate )，那些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP 协议就认为哪个延迟的数据时属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接要在 TIME_WAIT 状态等待两倍 MSL ，保证本次连接的所有数据都从网络中消失。
>



#### 2.HTTP协议



 **什么是HTTP?**

> ​		超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。

发展历史：

> ​      版本	产生时间												内容																				发展现状
> HTTP/0.9	1991年	不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求	  没有作为正式的标准
> HTTP/1.0	1996年	传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令	   正式作为标准
> HTTP/1.1	1997年	持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码	        2015年前使用最广泛
> HTTP/2	    2015年    多路复用、服务器推送、头信息压缩、二进制协议等	                                           逐渐覆盖市场



**什么是HTTPS？**

> 《图解HTTP》这本书中曾提过HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。
>
> PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。



**HTTP特点：**

1. 无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作
2. 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。
3. 基于请求和响应：基本的特性，由客户端发起请求，服务端响应
4. 简单快速、灵活
5. 通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性



**HTTPS特点：**

​		基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护



#### 3.Robots协议

​		Robots协议，该协议也称为爬虫协议及全称是网络爬虫排除协议。该协议指明了哪些页面可以抓取，哪些页面不能抓取，以及抓取动作的时间，延时，频次限定。爬虫遵守这一规则能够保证互联网数据采集的规范化，有利于行业的健康发展。



#### 4.Cookie规范	

​		是指某些网站为了辨别用户身份进行session跟踪。而存储在用户本地设备上的数据。通过cookie可以将用户在服务端的相关信息保存在本地，这些信息通常是用户名口令，地区标示的这些信息，会由浏览器自动读出，并通过HTTP协议。发送到服务端。



#### 5.网页编码规范

​		网页编码是指对网页中的字符采用的编码方式，例如UTF-8



#### 6.HTML语言规范

​		即html超文本标记语言的语法规范格式



#### 7.字符编码

##### 		ASCII

​					ASCII 码使用指定的7 位或8 位的二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二			进制数（最高的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制符号。

> 字符0-9的ASCII码：48-57；
>
> 大写字母A-Z的ASCII码为：65-90；
>
> 小写字母a-z的ASCII码为：97-122；
>
> 空字符的ASCII码为0；
>
> 制表符的ASCII码为9；
>
> 换行符的ASCII码为10。

##### 	GB2313

GB 2312
《信息交换用汉字编码字符集》是由中国国家标准总局1980年发布，1981年5月1日开始实施的一套国家标准，标准号是GB 2312—1980。

GB2312编码适用于汉字处理、汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB 2312。

基本集共收入汉字6763个和非汉字图形字符682个。整个字符集分成94个区，每区有94个位。每个区位上只有一个字符，因此可用所在的区和位来对汉字进行编码，称为区位码。

把换算成十六进制的区位码加上2020H，就得到国标码。国标码加上8080H，就得到常用的计算机机内码。1995年又颁布了《汉字编码扩展规范》（GBK）。GBK与GB 2312—1980国家标准所对应的内码标准兼容，同时在字汇一级支持 ISO/IEC10646—1 和 GB 13000—1 的全部中、日、韩（CJK）汉字，共计20902字。



> gb2313使用两个字节连在一起表示一个汉字，两个字节中前一个称为高字节。范围0xA1-0xF7。后一个称为低字节。范围0xA1~ 0xFE。编码范围为0xA1A1~0xF7FE



##### GBK

GBK编码范围：`8140－FEFE`，汉字编码范围见第二节：码位分配及顺序。

`GBK`编码，是对`GB2312`编码的扩展，因此完全兼容`GB2312-80`标准。`GBK`编码依然采用双字节编码方案，其编码范围：`8140－FEFE`，剔除`xx7F`码位，共23940个码位。共收录汉字和图形符号21886个，其中汉字（包括部首和构件）21003个，图形符号883个。`GBK`编码支持国际标准`ISO/IEC10646-1`和国家标准`GB13000-1`中的全部中日韩汉字，并包含了BIG5编码中的所有汉字。`GBK`编码方案于1995年12月15日正式发布，这一版的`GBK`规范为1.0版



##### Unicode 编码方案

之前提到，Unicode 没有规定字符对应的二进制码如何存储。以汉字“汉”为例，它的 Unicode 码点是 0x6c49，对应的二进制数是 110110001001001，二进制数有 15 位，这也就说明了它至少需要 2 个字节来表示。可以想象，在 Unicode 字典中往后的字符可能就需要 3 个字节或者 4 个字节，甚至更多字节来表示了。

这就导致了一些问题，计算机怎么知道你这个 2 个字节表示的是一个字符，而不是分别表示两个字符呢？这里我们可能会想到，那就取个最大的，假如 Unicode 中最大的字符用 4 字节就可以表示了，那么我们就将所有的字符都用 4 个字节来表示，不够的就往前面补 0。这样确实可以解决编码问题，但是却造成了空间的极大浪费，如果是一个英文文档，那文件大小就大出了 3 倍，这显然是无法接受的。

于是，为了较好的解决 Unicode 的编码问题， UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了。当然还有一个 UTF-32 的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，虽然看似方便，但是却不如另外两种编码方式使用广泛。



##### UTF-8

UTF-8 是一个非常惊艳的编码方式，漂亮的实现了对 ASCII 码的向后兼容，以保证 Unicode 可以被大众接受。

UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：

对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。

对于需要使用 N 个字节来表示的字符（N > 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。